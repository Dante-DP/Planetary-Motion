import numpy as np
import matplotlib.pyplot as plt

# Parameters
m = 1.0       
k = 1.0   
omega = np.sqrt(k/m)

# Initial conditions
x0 = 1.0      
v0 = 0.0      

# Max time and step size
t_max = 20.0
dt = 0.01
t = np.arange(0, t_max + dt, dt)
N = len(t)

# Exact solution
x_exact = x0 * np.cos(omega*t) + (v0/omega) * np.sin(omega*t)
v_exact = -x0*omega*np.sin(omega*t) + v0*np.cos(omega*t)

# Plot x(t) 
plt.figure()
plt.plot(t, x_exact, label='Exact x(t)')
plt.xlabel('t')
plt.ylabel('x')
plt.title('Harmonic Oscillator: Position vs Time')
plt.legend()
plt.grid(True)

# Phase-space (x(t), v(t)) comparison 
plt.figure()
plt.plot(x_exact, v_exact, label='Exact (x,v)')
plt.xlabel('x')
plt.ylabel('v')
plt.title('Harmonic Oscillator: Phase-Space Trajectory')
plt.legend()
plt.grid(True)

plt.show()

# Create arrays to store the numerical solution
x_verlet_alg = np.zeros(N)
v_verlet_alg = np.zeros(N)

# Set the values we have initially to the first index in the arrays
x_verlet_alg[0] = x0
v_verlet_alg[0] = v0

# The acceleration function
def acceleration(x):
    return -(k/m) * x

# Create a loop to use the verlet algorithm
for i in range(N - 1):
    current_a = acceleration(x_verlet_alg[i]) #the acceleration currently
    updated_x = x_verlet_alg[i] + v_verlet_alg[i]*dt + 0.5*current_a*(dt**2) #the updated position
    updated_a = acceleration(updated_x) #the updated acceleration, based on position
    updated_v = v_verlet_alg[i] + 0.5*(current_a + updated_a)*dt #the updated velocity, based on acceleration

    x_verlet_alg[i+1] = updated_x #store the results in the arrays
    v_verlet_alg[i+1] = updated_v

# Plot for numerical x(t)
plt.figure() 
plt.plot(t, x_verlet_alg, 'orange', linestyle=':', label='Numerical x(t)')
plt.xlabel('t')
plt.ylabel('x')
plt.title('Harmonic Oscillator: Numerical x(t) with Verlet Algorithm')
plt.legend()
plt.grid(True)

# Plot for numerical (x,v) - the Phase-space
plt.figure() 
plt.plot(x_verlet_alg, v_verlet_alg, 'orange', linestyle=':', label='Numerical (x,v)')
plt.xlabel('x')
plt.ylabel('v')
plt.title('Verlet Solution : (x,v) plot')
plt.legend()
plt.grid(True)

# The comparison plots for x(t)
plt.figure()
plt.plot(t, x_exact, label='Exact x(t)')
plt.plot(t, x_verlet_alg, color='orange', linestyle=':', label='Numerical x(t)')
plt.xlabel('t')
plt.ylabel('x')
plt.title('Exact vs Numerical: x(t) over t')
plt.legend()
plt.grid(True)

# The comparison plots for (x,v) - the Phase-space
plt.figure() 
plt.plot(x_exact, v_exact, label='Exact (x,v)')
plt.plot(x_verlet_alg, v_verlet_alg, color='orange', linestyle=':', label='Numerical (x,v)')
plt.xlabel('x')
plt.ylabel('v')
plt.title('Exact vs Numerical: (x,v)')
plt.legend()
plt.grid(True)

plt.show

#Graph interpretations q.1:
We have simulated the motion of an orbiting planet, using both the exact solution and the numerical solution, using the Verlet Algorithm.
Our first two graphs show the exact position x(t), giving us a sinusoidal curve and a phase-space trajectory (x,v), from which we get an elliptical curve. 
These perfect, smooth shapes demonstrate conservation of energy within our system. Using the Verlet algorithm, for the next two graphs of our numerical solutions, we find that these curves closely follow the previous two respectively.
The purpose of 0.01 as a time step ensures any deviations in the two different solutions are minimised, which allows the numerical solution to mimmick the exact orbit over time closely.

    

