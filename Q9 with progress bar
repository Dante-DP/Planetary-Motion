import numpy as np
import numpy.linalg as lag
import time
from datetime import datetime, timedelta
from tqdm import tqdm

G = 6.67348e-11

m_sun = 1.988420392e30
m_earth = 5.972000000e24
m_moon = 7.345828157e22

r_sun = 696340e3
r_earth = 6371e3
r_moon = 1737e3

# ======= Initial Conditions @ 21/6/2010 00:00:00 (All Given in a Heliocentric Reference Frame) =========== 

rE0 = np.array([-0.012083728, -1.394770664, -0.604680716]) * 1e11
rM0 = np.array([-0.015537064, -1.395982236, -0.605576290]) * 1e11

vE0 = np.array([ 2.930141099, -0.032094528, -0.013869403]) * 1e4 
vM0 = np.array([ 2.967343467, -0.121872473, -0.051163801]) * 1e4 

rS = np.zeros(3) # Sun Position fixed at the Origin

# ================ Maths pertaining to the Ecliptic Plane ========================

hE = np.cross(rE0, vE0) # The Normal Vector to the Ecliptic Plane
eclN = hE / lag.norm(hE) # The Unit Normal Vector to the Ecliptic Plane

# ======= Acceleration Functions (Provided Directly from Newton's Equations) ================

def accel_earth(rE,rM):
    rES = rS - rE # Vector going from Earth to Sun
    a = G * m_sun * rES / lag.norm(rES)**3

    rEM = rM - rE # Vector going from Earth to Moon
    a += G * m_moon * rEM / lag.norm(rEM)**3

    return a

def accel_moon(rE,rM):
    rMS = rS - rM # Vector going from Moon to Sun
    a = G * m_sun * rMS / lag.norm(rMS)**3

    rME = rE - rM #Vector going from Moon to Earth
    a += G * m_earth * rME / lag.norm(rME)**3

    return a

# ======== Velocity Verlet Integration ============

# Velocity Verlet Integration has an error proportional to (dt)^3 so as the time increases the estimates have a higher error margin

def verlet(rE,vE,rM,vM,dt): 
    
    # Current Accelerations
    
    aE = accel_earth(rE,rM)
    aM = accel_moon(rE,rM)
    
    # Update Positions
    
    rE_np1 = rE + vE * dt + 0.5 * aE * dt**2
    rM_np1 = rM + vM * dt + 0.5 * aM * dt**2

    # Update Accelerations

    aE_np1 = accel_earth(rE_np1, rM_np1)
    aM_np1 = accel_moon(rE_np1, rM_np1)

    # Update Velocities

    vE_np1 = vE + 0.5 * (aE + aE_np1) * dt
    vM_np1 = vM + 0.5 * (aM + aM_np1) * dt

    return rE_np1, vE_np1, rM_np1, vM_np1

# ========== Modelling for the Spatial Geometry of planetary motion =================

# The purpose of this function is to find whether the earth is inside the shadow cone of the moon.

def spatialGeometry(rE, rM): 

    # Vector Displacements
    
    rMS = rS - rM # Moon -> Sun Displacement vector
    rME = rE - rM # Moon -> Earth Displacement vector

    # Scalar Distances 
    
    sMS = lag.norm(rMS) # Sun -> Moon Distance Scalar
    sME = lag.norm(rME) # Moon -> Earth Distance Scalar

    shadowDirection = rMS/sMS # Unit Vector in Direction of the Shadow Axis

    # Length of Projection

    projection_length = np.dot(rME, shadowDirection) # This tells us how far along the shadow axis does the earth lies, as shadowDirection is a unit vector
    # a.b = ||a||cos(theta) if b is a unit vector, which shows us that this is in this case rME being projected onto the unit vector of the shadowDirection
    
    projection = projection_length * shadowDirection # This tells us the component of the Displacement vector that is in the direction of the shadow

    pDisp = rME - projection # Perpendicular Displacement Vector
    pDist = lag.norm(pDisp) # Perpendicular Distance (This is the minimising distance between the Earth and the Shadow Axis)

    return sMS, sME, pDist

# ======== Testing for an eclipse ===========

def eclipseTest(sMS, sME, pDist, debug=False):

    # Umbra cone length
    L = sMS * (r_moon / (r_sun - r_moon))

    # Radii
    umbraR = r_moon * (1 - sME / L) # Umbra Radius
    penumbraR = r_moon * (1 + sME / L) # Penumbra Radius
    
# ------------ debug area ------------------------------
    if debug:
        print("ECLIPSE TEST:")
        print(" L =", L)
        print(" umbraR =", umbraR)
        print(" penumbraR =", penumbraR)
        print(" pDist =", pDist)
        print()
# ----------------------------------------------------
    
    # For the Moon to completely block the sun the Umbra's Radius MUST be greater than 0
    if umbraR > 0:
        if pDist < umbraR + r_earth: # We add the Radius of the Earth as the Earth is not a point but approximately a sphere
            return "Total Eclipse"
        if pDist < penumbraR + r_earth: # As the p_dist is greater than the umbra's Radius + the radius of the earth the moon is partially blocking the Sun
            return "Partial Eclipse"
        return None

    # Umbra does NOT reach Earth, so you can only have an Annular Eclipse or No Eclipse
    else:
        if pDist < penumbraR + r_earth: # Moon's shadow is smaller than the light cone of the sun, so creates an annulus
            return "Annular Eclipse"
        return None
        
# ============ Rough Scan ===================

# The purpose of the rough scan is to find out potential candidates for the eclipses, this prevents us from having to run the simulation finely for an insanely long time
# to whittle down computational resources, we then proceed by running a fine scan to deal with this.

def rough_scan(years=15, dt=300): #dt is in seconds

    print("Rough Scan has Started")
    
    seconds = years * 365.25 * 24 * 3600
    steps = int(seconds/dt)

    # Initialise Position and Velocity Vectors of the moon to their Initial vectors
    
    rE, vE = rE0.copy(), vE0.copy()
    rM, vM = rM0.copy(), vM0.copy()

    
    eclipseEstimates = [] # List Containing the Times of our eclipse estimates on our rough scan.

    for step in tqdm(range(steps),desc="Rough Scan",unit="Steps"): # Loops through the cases, appending in the list possible candidates for eclipses
        t = step * dt

        rMS = rS - rM # Vector from moon -> sun
        rME = rE - rM # Vector from moon -> earth

        cos_angle = np.dot(rMS, rME) / (lag.norm(rMS)*lag.norm(rME)) # This is the angle between the vector from the Moon to the Sun and the vector from the Moon to the Earth.
        
        colinear = (cos_angle<-0.995) # The colinear check, checks that the 2 vectors are approximately colinear and the vectors are in opposite directions to eachother
        # the reason the restriction is to <-0.995 is so that it takes into account the error from the velocity verlet integration.

        moon_in_front = (np.dot(rMS, rME) < 0) # To account for potential errors (possibly redundant)

        # Ecliptic Plane Geometry Checks - This Check is necessary to whittle down candidates as to be an eclipse the moon must intersect the ecliptic plane.
        # Without this check the number of possible candidates increases by over 10x So this significantly reduces the runtime and increases the accuracy
        sEcliptic = abs(np.dot(rM, eclN)) # Distance from Moon to the Ecliptic Plane
        nodeTolerance = 3e6 
        near_node = (sEcliptic < nodeTolerance) # A node is an intesecting point of the ecliptic plane, this checks that the moon is near the node to a reasonable degree
        if colinear and near_node and moon_in_front: # All three checks must be successful in order for it to be a possible eclipse.
            eclipseEstimates.append(t)

        # Integrate to use for next step @ the next time step
        rE, vE, rM, vM = verlet(rE, vE, rM, vM, dt)

    print("Rough Scan Complete")
    
    return eclipseEstimates

# ========== Fine Scan ===============

# Since we already have the rough scan we can use the time values for our rough scan and look through the interval of the rough scan to work out the fine scan times.

def fine_scan(tc, window_hr=12, dt=10, dt_skip=300):

    # tc = time estimate, which is our center time.
    # window_hr = the window either side of tc in which it checks for the time of the solar eclipse in the fine scan
    # dt = The time steps within our window
    # dt_skip = The time steps outside our window
    
    t0 = max(0, tc - window_hr*3600) # Start Time (Max to prevent t0 being negative)
    t1 = tc + window_hr*3600 # End Time

    # Reset Initial Conditions
    rE, vE = rE0.copy(), vE0.copy()
    rM, vM = rM0.copy(), vM0.copy()

    t = 0 # Need to start @ t = 0 to do the integration as it's constantly moving.
    jump = 1800 # Jumps of 30 minutes is about optimal for as much accuracy while not sacrificing computational resources
    while t < t0 - jump:
        rE, vE, rM, vM = verlet(rE, vE, rM, vM, jump)
        t += jump

    # Then refine with dt_skip to integrate our way closer to t0 with minimal computational resources.
    while t < t0:
        step_dt = min(dt_skip, t0 - t)
        rE, vE, rM, vM = verlet(rE, vE, rM, vM, step_dt)
        t += step_dt

    
    t_ref = sMS_ref = sME_ref = None # Starts off with nothing but then gets appended as better estimation arises.
    pDist_ref = 1e20 # Refined Perpendicular Distance Estimate (which will get minimised) We start off super high and work our way down

    while t < t1:

        sMS, sME, pDist = spatialGeometry(rE,rM) # Computes the Geometry at the current t

        if pDist < pDist_ref: # Constantly keeps the most refined estimate for pDist and pDist_ref
            pDist_ref = pDist
            t_ref = t
            sMS_ref = sMS
            sME_ref = sME
                
        # Step Integrator
        rE, vE, rM, vM = verlet(rE, vE, rM, vM, dt)
        t += dt
        
    return t_ref, sMS_ref, sME_ref, pDist_ref

# ======== Convert seconds to datetime ========

initialTime = datetime(2010, 6, 21, 0, 0, 0) # Our Initial Time that we work from provided by the booklet.

# Following function converts the seconds into time
def dateConversion(t):
    return initialTime + timedelta(seconds=t) 

# ======== Computations ============

print("Run time has started")
start = time.time() # Starts timing the process
rough_times = rough_scan(years=15, dt=3600)
print("Number of Rough Candidates:",len(rough_times))

cleaned = [] # To avoid duplicate fine_scan calls to save computation time.
print("Cleaning Rough Scan List")
for t in rough_times:
    if not cleaned or abs(t-cleaned[-1]) > 86400: # The abs(t-cleaned[-1]) exists to only have one time to exist to be the representative for the eclipse
        cleaned.append(t)

rough_times = cleaned # Sets the rough times list as the cleaned list
print(f"Rough Scan list Cleaned to {len(rough_times)} Candidates")

refined_results = [] # List of the refined results

print("Fine Scan has Started")

for tc in tqdm(rough_times,desc="Fine Scan",unit="Candidates"):
    t_ref, sMS, sME, pDist = fine_scan(tc, window_hr=12, dt=10, dt_skip=300)
    refined_results.append((t_ref, sMS, sME, pDist)) 
print("Number of fine candidates:", len(refined_results))    
print("Fine Scan Complete")

# ======== Extract real eclipses from refined_results ========

def extract_eclipses(refined_results, debug=False):
    print("Extracting Eclipses")
    eclipse_list = [] # The list of eclipses

    for (t_ref, sMS, sME, pDist) in refined_results:
        etype = eclipseTest(sMS, sME, pDist) # Return the type of eclipse
        
# --------------------------- debug area ------------------------------------------
        if debug:
            print("t =",t_ref)
            print("sMS=",sMS)
            print("sME=",sME)
            print("pDist =",pDist)
            print("eclipseTest =", etype)
            print()
# -------------------------------------------------------------------------------------
        
        if etype is not None: # Eliminates Non-Eclipses to rid false positives
            eclipse_list.append((t_ref, etype))

    return eclipse_list

# =================== Print eclipse list =============================

def print_eclipses(eclipse_list):
    print(f"There are {len(eclipses)} predicted eclipses in this time period:")
    print("\nPredicted Eclipses (YYYY / MM / DD):\n")
    for t, etype in eclipse_list:
        print(f"{dateConversion(t)} | {etype:13}") # Prints the Date and Time and the type of eclipse


eclipses = extract_eclipses(refined_results)
print_eclipses(eclipses)
print("Total Runtime:",time.time() - start, "seconds")
