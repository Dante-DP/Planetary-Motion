import numpy as np
import numpy.linalg as lag
import time
from datetime import datetime, timedelta

G = 6.67348e-11

m_sun = 1.988420392e30
m_earth = 5.972000000e24
m_moon = 7.345828157e22

r_sun = 696340e3
r_earth = 6371e3
r_moon = 1737e3

# ======= Initial Conditions @ 21/7/2010 00:00:00 (All Given in a Heliocentric Reference Frame) =========== 

rE0 = np.array([-0.012083728, -1.394770664, -0.604680716]) * 1e11
rM0 = np.array([-0.015537064, -1.395982236, -0.605576290]) * 1e11

vE0 = np.array([ 2.930141099, -0.032094528, -0.013869403]) * 1e4 
vM0 = np.array([ 2.967343467, -0.121872473, -0.051163801]) * 1e4 

rS = np.zeros(3) # Sun Position fixed at the Origin

# ======= Acceleration Functions (Provided Directly from Newton's Equations) ================

def accel_earth(rE,rM):
    rES = rS - rE # Vector going from Earth to Sun
    a = G * m_sun * rES / lag.norm(rES)**3

    rEM = rM - rE # Vector going from Earth to Moon
    a += G * m_moon * rEM / lag.norm(rEM)**3

    return a

def accel_moon(rE,rM):
    rMS = rS - rM # Vector going from Moon to Sun
    a = G * m_sun * rMS / lag.norm(rMS)**3

    rME = rE - rM #Vector going from Moon to Earth
    a += G * m_earth * rME / lag.norm(rME)**3

    return a

# ======== Velocity Verlet Integration ============

def verlet(rE,vE,rM,vM,dt):
    
    # Current Accelerations
    
    aE = accel_earth(rE,rM)
    aM = accel_moon(rE,rM)
    
    # Update Positions
    
    rE_np1 = rE + vE * dt + 0.5 * aE * dt**2
    rM_np1 = rM + vM * dt + 0.5 * aM * dt**2

    # Update Accelerations

    aE_np1 = accel_earth(rE_np1, rM_np1)
    aM_np1 = accel_moon(rE_np1, rM_np1)

    # Update Velocities

    vE_np1 = vE + 0.5 * (aE + aE_np1) * dt
    vM_np1 = vM + 0.5 * (aM + aM_np1) * dt

    return rE_np1, vE_np1, rM_np1, vM_np1

# ========== Modelling for the Spatial Geometry of planetary motion =================

def spatialGeometry(rE, rM):
    
    rES = rS - rE # Displacement Earth -> Sun
    rEM = rM - rE # Displacement Earth -> Moon

    sES = lag.norm(rES) # Distance Earth -> Sun (From Vector)
    sEM = lag.norm(rEM) # Distance Earth -> Moon (From Vector)

    sun_angle = np.arcsin(r_sun/sES) # Angle of the Sun's Center to the Edge from Earth
    moon_angle = np.arcsin(r_moon/sEM) # Angle of the Moon's Center to the Edge from Earth

    # Angular Seperation

    cos_ang_sep = np.dot(rES,rEM)/(sEM*sES)
    cos_ang_sep = np.clip(cos_ang_sep, -1, 1) # This is done so arccos doesnt produce an error
    ang_sep = np.arccos(cos_ang_sep)

    return sES, sEM, sun_angle, moon_angle, ang_sep

# ======== Testing for an eclipse ===========

def eclipseTest(sun_angle, moon_angle, ang_sep, sEM):

    earth_parallax = np.arcsin(r_earth / sEM) # Parallax exists to account for small deviations
    
    if ang_sep > sun_angle + moon_angle + earth_parallax:
        return None # There is no eclipse

    if moon_angle >= sun_angle: # The Disc's overlap and the Moon appears Larger
        if ang_sep <= moon_angle - sun_angle + earth_parallax:
            return "total eclipse"
        else:
            return "partial eclipse"

    else: # The Disc's overlap and the Sun Appears Larger
        if ang_sep <= sun_angle - moon_angle + earth_parallax:
            return "annular eclipse"
        else:
            return "partial eclipse"
        
# ============ Rough Scan ===================

# The purpose of the rough scan is to find out potential candidates for the eclipses, this prevents us from having to run the simulation finely for an insanely long time
# to whittle down computational resources, we then proceed by running a fine scan to deal with this.

def rough_scan(years=15, dt=300): #dt is in seconds

    seconds = years * 365.25 * 24 * 3600
    steps = int(seconds/dt)

    # Initialise Position and Velocity Vectors of the moon to their Initial vectors
    
    rE, vE = rE0.copy(), vE0.copy()
    rM, vM = rM0.copy(), vM0.copy()

    
    eclipseEstimates = [] # List Containing the Times of our eclipse estimates on our rough scan.

    for step in range(steps): # Loops through the cases, appending in the list possible candidates for eclipses
        t = step * dt

        # Compute Spatial Geometry @ time = t
        sES, sEM, sun_angle, moon_angle, ang_sep = spatialGeometry(rE, rM)

        # If the separation is less than sum of angular radii + generous buffer we consider it a candidate
        if ang_sep < (sun_angle + moon_angle + 0.01):  
            eclipseEstimates.append(t)

        # Integrate to use for next step @ the next time step
        rE, vE, rM, vM = verlet(rE, vE, rM, vM, dt)

    return eclipseEstimates

# ========== Fine Scan ===============

# Since we already have the rough scan we can use the time values for our rough scan and look through the interval of the rough scan to work out the fine scan times.

def fine_scan(tc, window_hr=12, dt=10, dt_skip=300):
    # tc = time estimate, which is our center time.
    # window_hr = the window either side of tc in which it checks for the time of the solar eclipse in the fine scan
    # dt = The time steps within our window
    # dt_skip = The time steps outside our window
    
    t0 = max(0, tc - window_hr*3600) # Start Time (Max to prevent t0 being negative)
    t1 = tc + window_hr*3600 # End Time

    # Reset Initial Conditions
    rE, vE = rE0.copy(), vE0.copy()
    rM, vM = rM0.copy(), vM0.copy()

    t = 0
    # Fast-forward in huge steps (1 day)
    day = 86400
    while t < t0 - day: # We integrate up to t0-day because we inntegrating in time steps of 1 day can go up to just under 1 day above t0 and then the finer integration starts.
        rE, vE, rM, vM = verlet(rE, vE, rM, vM, day)
        t += day

    # Then refine with dt_skip to integrate our way closer to t0 with minimal computational resources.
    while t < t0:
        step_dt = min(dt_skip, t0 - t)
        rE, vE, rM, vM = verlet(rE, vE, rM, vM, step_dt)
        t += step_dt

    
    t_ref = None # Starts off with nothing but then gets appended as better estimation arises.
    min_ang_sep = 10 # Large Number for high-res

    while t < t1:
        
        # Spatial Geometry in the window
        sES, sEM, sun_angle, moon_angle, ang_sep = spatialGeometry(rE, rM)

        # This step here keeps track of the most refined estimate of t
        
        if ang_sep < min_ang_sep:
            min_ang_sep = ang_sep
            t_ref = t 

        # Step Integrator
        rE, vE, rM, vM = verlet(rE, vE, rM, vM, dt)
        t += dt

    return t_ref, min_ang_sep

# ======== Convert seconds to datetime ========

initialTime = datetime(2010, 6, 21, 0, 0, 0) # Our Initial Time that we work from provided by the booklet.

# Following function converts the seconds into time
def dateConversion(t):
    return initialTime + timedelta(seconds=t) 


# ======== Compute geometry at exact time t ========
    
def geometry_at_time(t):
    rE, vE = rE0.copy(), vE0.copy()
    rM, vM = rM0.copy(), vM0.copy()

    day = 86400      # 1 day
    time_passed = 0

    #The following is the same method we used in fine_scan
    # Large jumps first
    while time_passed < t - day:
        rE, vE, rM, vM = verlet(rE, vE, rM, vM, day)
        time_passed += day
    
    # Final refinement
    while time_passed < t:
        step = min(300, t - time_passed)
        rE, vE, rM, vM = verlet(rE, vE, rM, vM, step)
        time_passed += step

    return spatialGeometry(rE, rM)

# ======== Computations ============
    
start = time.time() # Here for debugging, just checking the runtime of the program
rough_times = rough_scan(years=15, dt=3600)

cleaned = [] # To avoid duplicate fine_scan calls to save computation time.

for t in rough_times:
    if not cleaned or abs(t-cleaned[-1]) > 86400: # The abs(t-cleaned[-1]) exists to only have one time to exist to be the representative for the eclipse
        cleaned.append(t)

rough_times = cleaned # Sets the rough times list as the cleaned list

refined_results = [] # List of the refined results

for tc in rough_times:
    t_ref, min_ang_sep = fine_scan(tc, window_hr=12, dt=10, dt_skip=300)
    refined_results.append((t_ref, min_ang_sep)) 
    
# ======== Extract real eclipses from refined_results ========

def extract_eclipses(refined_results):
    eclipse_list = [] # The list of eclipses

    for (t_ref, min_sep) in refined_results:
        sES, sEM, sun_angle, moon_angle, ang_sep = geometry_at_time(t_ref) # Calculate the Geometry at the most refined time
        etype = eclipseTest(sun_angle, moon_angle, ang_sep, sEM) # Return the type of eclipse

        if etype is not None: # Eliminates Non-Eclipses to rid false positives
            eclipse_list.append((t_ref, etype, ang_sep))

    return eclipse_list

# =================== Print eclipse list =============================

def print_eclipses(eclipse_list):
    print("Predicted Eclipses:\n")
    for t, etype, sep in eclipse_list:
        print(f"{dateConversion(t)} | {etype:13} | seperation = {sep:.6f}") # Prints the Date and Time, The Type of Eclipse, and then the seperation


eclipses = extract_eclipses(refined_results)
print_eclipses(eclipses)
print("Total Runtime:",time.time() - start, "seconds")
